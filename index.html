<!DOCTYPE html>
<html lang="ja">
<head>
  <meta name="google-adsense-account" content="ca-pub-7114382915864844">
  <meta charset="UTF-8">
  <title>一筆書きパズル</title>
<style>
  body { text-align: center; font-family: sans-serif; }
  canvas { border: 2px solid black; margin-top: 10px; }
  .controls { margin-top: 10px; }
  button { margin: 3px; padding: 6px 12px; }
</style>
</head>
<body>
<h1>一筆書きパズル</h1>
<p>スタート地点をクリック → 「スタート」ボタンで探索開始。<br>右クリックで障害ブロックを設置／削除できます。</p>

<div class="controls">
  <label>行: <input type="number" id="rows" value="5" min="2" max="15"></label>
  <label>列: <input type="number" id="cols" value="5" min="2" max="15"></label>
  <button id="generate">盤面生成</button>
  <button id="solve">スタート</button>
  <button id="reset">リセット</button>
</div>

<canvas id="board" width="400" height="400"></canvas>

<script>
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const generateBtn = document.getElementById('generate');
const solveBtn = document.getElementById('solve');
const resetBtn = document.getElementById('reset');
let rows = 5, cols = 5;
let grid = [];
let start = null;
let cellSize;
let path = [];

function createGrid() {
  grid = [];
  for (let r = 0; r < rows; r++) {
    const row = [];
    for (let c = 0; c < cols; c++) {
      row.push(0); // 0=空白, 1=障害
    }
    grid.push(row);
  }
  start = null;
  draw();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  cellSize = Math.min(canvas.width / cols, canvas.height / rows);
  ctx.lineWidth = 1;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      ctx.strokeStyle = "black";
      ctx.strokeRect(c * cellSize, r * cellSize, cellSize, cellSize);
      if (grid[r][c] === 1) {
        ctx.fillStyle = "gray";
        ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
      }
    }
  }
  if (start) {
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(
      start.c * cellSize + cellSize / 2,
      start.r * cellSize + cellSize / 2,
      cellSize / 4,
      0, Math.PI * 2
    );
    ctx.fill();
  }
  if (path.length > 0) {
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(
      path[0].c * cellSize + cellSize / 2,
      path[0].r * cellSize + cellSize / 2
    );
    for (const p of path) {
      ctx.lineTo(
        p.c * cellSize + cellSize / 2,
        p.r * cellSize + cellSize / 2
      );
    }
    ctx.stroke();
  }
}

canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const c = Math.floor(x / cellSize);
  const r = Math.floor(y / cellSize);
  if (grid[r][c] === 1) return; // 障害マスはスタート不可
  start = {r, c};
  draw();
});

canvas.addEventListener('contextmenu', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const c = Math.floor(x / cellSize);
  const r = Math.floor(y / cellSize);
  if (start && start.r === r && start.c === c) return; // スタート地点は障害にできない
  grid[r][c] = grid[r][c] === 1 ? 0 : 1; // トグル
  draw();
});

generateBtn.onclick = () => {
  rows = parseInt(document.getElementById('rows').value);
  cols = parseInt(document.getElementById('cols').value);
  createGrid();
};

resetBtn.onclick = () => {
  path = [];
  draw();
};

solveBtn.onclick = () => {
  if (!start) {
    alert("スタート地点をクリックして指定してください。");
    return;
  }
  const visited = Array.from({length: rows}, () => Array(cols).fill(false));
  path = [];
  const total = rows * cols - grid.flat().filter(v => v === 1).length;
  const result = dfs(start.r, start.c, visited, total);
  if (!result) alert("一筆書きは見つかりませんでした。");
  draw();
};

function dfs(r, c, visited, remain) {
  if (grid[r][c] === 1 || visited[r][c]) return false;
  visited[r][c] = true;
  path.push({r, c});
  if (path.length === remain) return true;

  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  for (const [dr, dc] of dirs) {
    const nr = r + dr, nc = c + dc;
    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc] && grid[nr][nc] === 0) {
      if (dfs(nr, nc, visited, remain)) return true;
    }
  }
  path.pop();
  visited[r][c] = false;
  return false;
}

// 初期盤面生成
createGrid();
</script>
</body>
</html>

